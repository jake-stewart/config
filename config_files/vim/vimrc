let g:use_coc = 1

"
" COMPATIBILITY
"

set nocompatible

if has("mouse_sgr")
    set ttymouse=sgr
else
    set ttymouse=xterm2
end

" if &term == "xterm-256color"
"     let &t_SI = "\<Esc>[5 q"
"     let &t_EI = "\<Esc>[1 q"
"     let &t_SR = "\<Esc>[4 q"
"     let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
"     let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
"     let &t_Cs = "\e[4:3m"
"     let &t_Ce = "\e[4:0m"
" endif

" tmux
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <c-w>h :TmuxNavigateLeft<cr>
nnoremap <silent> <c-w>j :TmuxNavigateDown<cr>
nnoremap <silent> <c-w>k :TmuxNavigateUp<cr>
nnoremap <silent> <c-w>l :TmuxNavigateRight<cr>

command! TmuxQuit call TmuxQuit()
nnoremap <silent> <c-w>q :TmuxQuit<CR>


function! TmuxQuit()
    if &modified
        echo "Error: Buffer is modified"
        return
    endif
    if win_getid(2) == 0
        !tmux killp
    else
        quit
    endif
endfunction


"
" APPEARANCE
"



set title
set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:h\")})%)%(\ %a%)
set background=dark
set termguicolors
syntax on
colorscheme custom

set shortmess+=I   " remove start page
set guioptions=c!  " remove gvim widgets
set noshowmode     " hide --INSERT--
set laststatus=0   " hide statusbar
set ruler
set number
set cursorline
set belloff=all    " disable sound
set showcmd

hi Comment gui=italic cterm=italic
hi Todo gui=italic cterm=italic


"
" SETTINGS
"

set noswapfile

" splits
set splitright
set splitbelow

" whitespace
set tabstop=8
set softtabstop=0
set expandtab
set shiftwidth=4
set smarttab

" persistant undo
exe "set undodir=" . fnamemodify($MYVIMRC, ":h") . "/undodir"
set undofile

" searching
set hlsearch
set incsearch
set smartcase
set ignorecase

" other
set lazyredraw                      " run macros without updating screen
set clipboard^=unnamed,unnamedplus  " make vim use system clipboard
set encoding=utf-8                  " unicode characters
set hidden                          " allow buffer switching without saving
set backspace=indent,eol,start      " make backspace work as expected
set mouse=a                         " enable mouse
set ttimeoutlen=1                   " time waited for terminal codes


"
" PLUGINS
"

let g:polyglot_disabled = ['autoindent', 'sensible', 'ftdetect']

" vimplug
call plug#begin("~/.vim/plugged")
Plug 'christoomey/vim-tmux-navigator'
Plug 'machakann/vim-swap'
Plug 'glts/vim-textobj-comment'
Plug 'tpope/vim-commentary'
Plug 'kana/vim-textobj-user'
Plug 'bfrg/vim-cpp-modern'
Plug 'sheerun/vim-polyglot'
Plug 'michaeljsmith/vim-indent-object'
Plug 'wellle/targets.vim'
Plug 'machakann/vim-sandwich'
Plug 'junegunn/vim-easy-align'

if g:use_coc
    Plug 'neoclide/coc.nvim', {'branch': 'release'}
    nmap <silent> gd <Plug>(coc-definition)
    nmap <silent> gy <Plug>(coc-type-definition)
    nmap <silent> gi <Plug>(coc-implementation)
    nmap <silent> gr <Plug>(coc-references)

    " Use tab for trigger completion with characters ahead and navigate.
    " NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
    " other plugin before putting this into your config.
    inoremap <silent><expr> <TAB>
          \ pumvisible() ? "\<C-n>" :
          \ <SID>check_back_space() ? "\<TAB>" :
          \ coc#refresh()
    inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

    function! s:check_back_space() abort
      let col = col('.') - 1
      return !col || getline('.')[col - 1]  =~# '\s'
    endfunction
end

Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
nnoremap <c-k> :FZF<cr>

call plug#end()

set signcolumn=number



"
" OTHER PLUGIN SETTINGS
"

" vim-easy-align
xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)

" vim-sandwich
runtime macros/sandwich/keymap/surround.vim

" targets.vim
autocmd User targets#mappings#user call targets#mappings#extend({
    \ 'b': {'pair': [{'o':'(', 'c':')'}]}
    \ })
nmap cia cIa
nmap dia dIa
nmap yia yIa


" AUTOCOMMANDS

autocmd BufNewFile,BufRead *.jn setf jnote
autocmd BufNewFile,BufRead *.tbl setf tablescript
autocmd FileType * setlocal fo-=c fo-=r fo-=o  " remove autocommenting

" go to last position before exiting vim
au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif


"
" MAPPINGS
"


let mapleader = "t"

nnoremap <expr><leader>j Slide(1, 0)
vnoremap <expr><leader>j Slide(1, 0)
nnoremap <expr><leader>k Slide(-1, 0)
vnoremap <expr><leader>k Slide(-1, 0)

nnoremap <expr><leader>J Slide(1, 1)
vnoremap <expr><leader>J Slide(1, 1)
nnoremap <expr><leader>K Slide(-1, 1)
vnoremap <expr><leader>K Slide(-1, 1)

" remove search highlighting
nnoremap <silent><space> :noh<CR>

" toggle cursor column 
nnoremap <silent><leader>c :exec &cuc ? "set nocuc" : "set cuc"<CR>

" Make Y act like C and D
nnoremap Y y$

" Replace Ex mode with run q macro
nnoremap Q @q

" map <c-k>zs to zero-width space
exe 'digraph zs ' . 0x200b


" FUNCTIONS
function! SynStack()
    if !exists("*synstack")
        return
    endif
    return map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunction

function! VirtIdx(string, idx)
    if len(a:string) == 0
        return ' '
    endif
    let l:idx = 0
    for char in a:string
        if char == "\t"
            let l:idx = (l:idx / &ts + 1) * &ts
        else
            let l:idx += strdisplaywidth(char)
        endif

        if l:idx >= a:idx
            break
        endif
    endfor
    return char
endfunction

function! Slide(direction, smart_syntax)
    let l:syntax = a:smart_syntax && exists("*synstack")

    let l:col = col('.')
    let l:line = line('.')
    let l:max_line = line('$')

    if l:syntax
        let l:stack = synstack(line('.'), col('.'))
    endif

    if l:col > 1
        let l:char_before = VirtIdx(getline(l:line), l:col - 1)
        let l:space_before = (l:char_before == ' ' || l:char_before == '' || l:char_before == '	')
    endif

    let l:char_after = VirtIdx(getline(l:line), l:col)
    let l:space_after = l:char_after == ' ' || l:char_after == '' || l:char_after == '	'

    while 1
        let l:line += a:direction

        if l:line > l:max_line || l:line == 0
            break
        endif

        if strdisplaywidth(getline(l:line)) < l:col - 1
            break
        endif

        if l:syntax
            let l:newstack = synstack(l:line, l:col)
            if len(l:newstack) == 0
                if len(l:stack) > 0
                    let g:bruh = 1
                    break
                endif
            elseif len(l:stack) == 0
                let g:bruh = 2
                break
            elseif l:stack[-1] != l:newstack[-1]
                let g:bruh = 3
                break
            endif
        endif

        let l:char_after = VirtIdx(getline(l:line), l:col)
        let l:new_space_after = l:char_after == ' ' || l:char_after == '' || l:char_after == '	'
        if l:new_space_after != l:space_after
            break
        endif

        if l:col > 1
            let l:char_before = VirtIdx(getline(l:line), l:col - 1)
            let l:new_space_before = (l:char_before == ' ' || l:char_before == '' || l:char_before == '	')
            if l:new_space_before != l:space_before
                break
            endif
        endif
    endwhile

    if a:direction == 1
        let l:jump = l:line - line('.') - 1
        let l:jump_char = 'j'
    else
        let l:jump = line('.') - l:line - 1
        let l:jump_char = 'k'
    endif

    if l:jump == 0
        return ''
    elseif l:jump == 1
        return l:jump_char
    else
        return l:jump . l:jump_char
    endif
endfunction
